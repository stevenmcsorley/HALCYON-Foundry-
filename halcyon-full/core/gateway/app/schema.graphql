scalar DateTime

type Query {
  health: String!
  entities(type: String): [Entity!]!
  entityById(id: ID!): Entity
  relationships: [Relationship!]!
  federatedEntities(source: String!, type: String, limit: Int = 200): [Entity!]!
  savedQueries: [SavedQuery!]!
  savedQuery(id: ID!): SavedQuery
  dashboards: [Dashboard!]!
  dashboard(id: ID!): DashboardWithPanels
  datasources(status: String, type: String, ownerId: String, orgId: ID, projectId: ID, search: String, limit: Int, offset: Int): [Datasource!]!
  datasource(id: ID!): Datasource
  datasourceVersions(id: ID!, limit: Int, offset: Int): [DatasourceVersion!]!
  datasourceEvents(id: ID!, limit: Int, offset: Int, eventType: String): [DatasourceEvent!]!
  datasourceState(id: ID!): DatasourceRuntimeState!
  datasourceSecrets(id: ID!): [DatasourceSecret!]!
  alertRules: [AlertRule!]!
  alerts(status: String, severity: String): [Alert!]!
  cases(status: String, owner: String, priority: String, search: String, limit: Int, offset: Int): [Case!]!
  case(id: ID!): Case
  feedbackByCase(caseId: ID!): [FeedbackEvent!]!
  alertActions(alertId: ID!): [ActionAttempt!]!
  alertRoutePreview(alertId: ID!): [RouteDecision!]!
  playbookBindings(ruleId: Int, enabled: Boolean, mode: PlaybookMode): [PlaybookBinding!]!
  playbookRunAudit(alertId: Int!): [PlaybookRunAudit!]!
}

type Mutation {
  upsertEntities(input: [EntityInput!]!): Boolean!
  upsertRelationships(input: [RelationshipInput!]!): Boolean!
  createSavedQuery(input: SavedQueryInput!): SavedQuery!
  updateSavedQuery(id: ID!, input: SavedQueryUpdateInput!): SavedQuery!
  deleteSavedQuery(id: ID!): Boolean!
  createDashboard(input: DashboardInput!): Dashboard!
  updateDashboard(id: ID!, input: DashboardUpdateInput!): Dashboard!
  deleteDashboard(id: ID!): Boolean!
  createPanel(dashboardId: ID!, input: PanelInput!): Panel!
  updatePanel(dashboardId: ID!, panelId: ID!, input: PanelUpdateInput!): Panel!
  deletePanel(dashboardId: ID!, panelId: ID!): Boolean!
  createDatasource(input: DatasourceInput!): Datasource!
  updateDatasource(id: ID!, input: DatasourceUpdateInput!): Datasource!
  archiveDatasource(id: ID!): Boolean!
  createDatasourceVersion(id: ID!, input: DatasourceVersionInput!): DatasourceVersion!
  publishDatasourceVersion(id: ID!, version: Int!, comment: String): DatasourceVersion!
  rollbackDatasource(id: ID!, targetVersion: Int!, comment: String): DatasourceVersion!
  startDatasource(id: ID!): DatasourceRuntimeState!
  stopDatasource(id: ID!): DatasourceRuntimeState!
  restartDatasource(id: ID!): DatasourceRuntimeState!
  testDatasource(id: ID!, payload: JSON!, version: Int, configOverride: JSON): DatasourceTestResult!
  backfillDatasource(id: ID!): Boolean!
  upsertDatasourceSecret(id: ID!, key: String!, value: String!): DatasourceSecret!
  deleteDatasourceSecret(id: ID!, key: String!): Boolean!
  createAlertRule(input: AlertRuleInput!): AlertRule!
  updateAlertRule(id: ID!, input: AlertRuleInput!): AlertRule!
  deleteAlertRule(id: ID!): Boolean!
  acknowledgeAlert(id: ID!): Alert!
  resolveAlert(id: ID!): Alert!
  createCase(input: CaseInput!): Case!
  updateCase(id: ID!, input: CaseUpdateInput!): Case!
  addCaseNote(caseId: ID!, body: String!): CaseNote!
  assignAlertsToCase(caseId: ID!, alertIds: [ID!]!): Boolean!
  adoptPrioritySuggestion(caseId: ID!): Case!
  adoptOwnerSuggestion(caseId: ID!): Case!
  provideFeedback(input: ProvideFeedbackInput!): FeedbackEvent!
  alertRetry(alertId: ID!, dest: String!): ActionAttempt!
  alertRetryAllFailed(alertId: ID!): [ActionAttempt!]!
  createPlaybookBinding(input: PlaybookBindingInput!): PlaybookBinding!
  updatePlaybookBinding(id: ID!, input: PlaybookBindingInput!): PlaybookBinding!
  deletePlaybookBinding(id: ID!): Boolean!
  evaluateBindings(alertId: Int!): [PlaybookRunAudit!]!
  runBinding(alertId: Int!, bindingId: Int!): PlaybookRunAudit!
}

type Entity {
  id: ID!
  type: String!
  attrs: JSON!
}

input EntityInput {
  id: ID!
  type: String!
  attrs: JSON!
}

type Relationship {
  type: String!
  fromId: ID!
  toId: ID!
  attrs: JSON!
}

input RelationshipInput {
  type: String!
  fromId: ID!
  toId: ID!
  attrs: JSON!
}

scalar JSON

type SavedQuery {
  id: ID!
  name: String!
  owner: String!
  gql: String!
  shapeHint: String
  createdAt: String!
  updatedAt: String!
}

input SavedQueryInput {
  name: String!
  gql: String!
  shapeHint: String
}

input SavedQueryUpdateInput {
  name: String
  gql: String
  shapeHint: String
}

type Dashboard {
  id: ID!
  name: String!
  owner: String!
  createdAt: String!
  updatedAt: String!
}

type DashboardWithPanels {
  id: ID!
  name: String!
  owner: String!
  createdAt: String!
  updatedAt: String!
  panels: [Panel!]!
}

type Datasource {
  id: ID!
  name: String!
  description: String
  type: String!
  ownerId: String
  orgId: ID
  projectId: ID
  tags: [String!]!
  status: String!
  createdAt: DateTime!
  createdBy: String
  updatedAt: DateTime!
  updatedBy: String
  archivedAt: DateTime
  currentVersion: Int
  state: DatasourceState
}

type DatasourceState {
  workerStatus: String
  lastHeartbeatAt: DateTime
  lastEventAt: DateTime
  errorCode: String
  errorMessage: String
  metrics: JSON
  updatedAt: DateTime
}

type DatasourceRuntimeState {
  datasource: Datasource
  running: Boolean!
}

type DatasourceVersion {
  version: Int!
  state: String!
  config: JSON!
  summary: String
  createdAt: DateTime!
  createdBy: String
  approvedAt: DateTime
  approvedBy: String
}

type DatasourceEvent {
  id: ID!
  version: Int
  eventType: String!
  actor: String
  payload: JSON
  createdAt: DateTime!
}

type DatasourceTestResult {
  success: Boolean!
  output: JSON
  warnings: [String!]
  logs: [String!]
}

type DatasourceSecret {
  key: String!
  version: Int!
  createdAt: DateTime!
  createdBy: String
  rotatedAt: DateTime
  rotatedBy: String
}

input DatasourceInput {
  name: String!
  type: String!
  description: String
  ownerId: String
  orgId: ID
  projectId: ID
  tags: [String!]
  status: String
}

input DatasourceUpdateInput {
  name: String
  description: String
  ownerId: String
  orgId: ID
  projectId: ID
  tags: [String!]
  status: String
}

input DatasourceVersionInput {
  config: JSON!
  summary: String
}

input DashboardInput {
  name: String!
}

input DashboardUpdateInput {
  name: String
}

type Panel {
  id: ID!
  dashboardId: ID!
  title: String!
  type: String!
  config: JSON!
  position: Int!
  createdAt: String!
  updatedAt: String!
}

input PanelInput {
  title: String!
  type: String!
  config: JSON
  position: Int
}

input PanelUpdateInput {
  title: String
  type: String
  config: JSON
  position: Int
}


type AlertRule {
  id: ID!
  name: String!
  description: String
  conditionJson: JSON!
  severity: String!
  actionsJson: JSON
  enabled: Boolean!
  createdAt: String!
  createdBy: String
}

type Alert {
  id: ID!
  ruleId: ID!
  entityId: String
  message: String!
  severity: String!
  status: String!
  caseId: ID
  createdAt: String!
  acknowledgedAt: String
  resolvedAt: String
  acknowledgedBy: String
  resolvedBy: String
}

type ActionAttempt {
  id: ID!
  alertId: ID!
  dest: String!
  status: String!
  httpStatus: Int
  error: String
  attempt: Int!
  scheduledAt: String
  sentAt: String
  createdAt: String!
}

type RouteDecision {
  dest: String!
  wouldSend: Boolean!
  reason: String!
  suppressed: Boolean!
}

type Case {
  id: ID!
  title: String!
  description: String
  status: String!
  priority: String!
  owner: String
  createdBy: String
  createdAt: String!
  updatedAt: String!
  resolvedAt: String
  prioritySuggestion: String
  ownerSuggestion: String
  similarCaseIds: [Int!]
  mlVersion: String
  feedback: [FeedbackEvent!]!
}

type CaseNote {
  id: ID!
  caseId: ID!
  author: String
  body: String!
  createdAt: String!
}

input ActionConfigInput {
  type: String!
  config: JSON
}

input AlertRuleInput {
  name: String!
  description: String
  conditionJson: JSON!
  severity: String!
  actionsJson: [ActionConfigInput!]
  enabled: Boolean!
}

input CaseInput {
  title: String!
  description: String
  status: String
  priority: String
  owner: String
}

input CaseUpdateInput {
  title: String
  description: String
  status: String
  priority: String
  owner: String
}

enum FeedbackAction {
  ACCEPTED
  REJECTED
  OVERRIDDEN
}

enum SuggestionType {
  PRIORITY
  OWNER
}

type FeedbackEvent {
  id: ID!
  caseId: ID!
  suggestionType: SuggestionType!
  suggestedValue: String!
  finalValue: String
  action: FeedbackAction!
  score: Float
  userId: String
  createdAt: String!
}

input ProvideFeedbackInput {
  caseId: ID!
  suggestionType: SuggestionType!
  suggestedValue: String!
  finalValue: String
  action: FeedbackAction!
  score: Float
}

enum PlaybookMode {
  suggest
  dry_run
  auto_run
}

type PlaybookBinding {
  id: ID!
  ruleId: Int
  playbookId: String!
  mode: PlaybookMode!
  matchTypes: [String!]
  matchSeverities: [String!]
  matchTags: [String!]
  maxPerMinute: Int!
  maxConcurrent: Int!
  dailyQuota: Int!
  enabled: Boolean!
  createdBy: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PlaybookRunAudit {
  id: ID!
  alertId: Int!
  bindingId: Int
  playbookId: Int!
  mode: PlaybookMode!
  decision: String!
  reason: String
  requestedBy: String
  startedAt: DateTime!
  finishedAt: DateTime
  success: Boolean
  outputRef: String
}

input PlaybookBindingInput {
  ruleId: Int
  playbookId: String!
  mode: PlaybookMode!
  matchTypes: [String!]
  matchSeverities: [String!]
  matchTags: [String!]
  maxPerMinute: Int
  maxConcurrent: Int
  dailyQuota: Int
  enabled: Boolean
}
